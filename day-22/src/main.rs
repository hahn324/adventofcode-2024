use std::{
    collections::{HashMap, HashSet},
    error::Error,
    fs,
};

fn main() -> Result<(), Box<dyn Error>> {
    let buyer_initial_secrets: Vec<isize> = fs::read_to_string("day-22/day22_input.txt")?
        .trim()
        .split('\n')
        .map(|num| num.parse().expect("Failed to parse initial secret number."))
        .collect();

    let mut secret_number_sum = 0;
    let num_to_generate = 2000;

    let mut price_sequence = [0; 4];
    let mut num_in_sequence = 1;

    let mut banana_tracker = HashMap::new();
    let mut sequence_tracker = HashSet::new();
    for mut secret_number in buyer_initial_secrets {
        for _ in 0..num_to_generate {
            let price = secret_number % 10;
            secret_number = get_next_secret(secret_number);
            let next_price = secret_number % 10;
            let price_change = next_price - price;

            if num_in_sequence == 4 {
                add_sequence(
                    next_price,
                    price_change,
                    &mut price_sequence,
                    &mut sequence_tracker,
                    &mut banana_tracker,
                );
            } else {
                price_sequence[num_in_sequence] = price_change;
                num_in_sequence += 1;
            }
        }
        secret_number_sum += secret_number;
        sequence_tracker.clear();
    }
    let (sequence, banana_max) = banana_tracker
        .iter()
        .max_by(|x, y| x.1.cmp(&y.1))
        .expect("Will find a max sequence value.");

    println!(
        "Sum of {num_to_generate}th secret number generated by each buyer: {secret_number_sum}"
    );
    println!(
        "The sequence {} will yield {} bananas",
        sequence, banana_max
    );

    Ok(())
}

fn add_sequence(
    price: isize,
    price_change: isize,
    price_sequence: &mut [isize; 4],
    sequence_tracker: &mut HashSet<String>,
    banana_tracker: &mut HashMap<String, isize>,
) {
    price_sequence[0] = price_sequence[1];
    price_sequence[1] = price_sequence[2];
    price_sequence[2] = price_sequence[3];
    price_sequence[3] = price_change;
    let key = price_sequence
        .iter()
        .map(|num| num.to_string())
        .collect::<String>();
    if !sequence_tracker.contains(&key) {
        sequence_tracker.insert(key.clone());
        banana_tracker
            .entry(key)
            .and_modify(|b| *b += price)
            .or_insert(price);
    }
}

fn get_next_secret(mut secret_number: isize) -> isize {
    // Step 1
    secret_number = prune(mix(secret_number, secret_number * 64));
    // Step 2
    secret_number = prune(mix(secret_number, secret_number / 32));
    // Step 3
    secret_number = prune(mix(secret_number, secret_number * 2048));

    secret_number
}

fn mix(secret_number: isize, other: isize) -> isize {
    secret_number ^ other
}

fn prune(secret_number: isize) -> isize {
    secret_number % 16777216
}
